# Отчёт по интеграционному тестированию ContentFilter (ручное тестирование) 

---

## I1: Перезапуск Redis

### Цель
Проверить корректность восстановления обработки сообщений после кратковременного отключения и последующего запуска Redis.

### Предусловия
- Контейнеры `content-filter` и `redis` запущены (`docker compose up -d`),  
- Redis очищен: `FLUSHDB`.

### Шаги и результаты

| № | Действие | Команда / Запрос | Ответ / Наблюдение | Статус |
|---|----------|------------------|---------------------|--------|
| 1 | Отправка тестового сообщения | `POST /check/ {"id":"i1_test","text":"test"}` | `{"id":"i1_test","status":"working"}` | ✅ |
| 2 | Проверка наличия ключа в Redis | `KEYS *` | `1) "i1_test"` | ✅ |
| 3 | Чтение значения *до* обработки | `GET i1_test` | `(nil)` | ✅ |
| 4 | Ожидание завершения обработки | `sleep 10` | — | — |
| 5 | Чтение значения *после* обработки | `GET i1_test` | `"{\"id\":\"i1_test\",\"verdict\":\"OK\"}"` | ✅ |
| 6 | Получение вердикта | `GET /verdict/ {"id":"i1_test"}` | `{"id":"i1_test","verdict":"OK"}` | ✅ |

### Анализ
- В Redis сохранён **ровно один JSON-объект**, без дублирования → ошибка `trailing characters at line 1 column 34` **устранена**.  
- API корректно сериализует и возвращает ответ.  
- Время обработки: ~8–10 сек (загрузка модели + инференс).

### Вывод
**Сценарий I1 пройден успешно.**  
Система демонстрирует устойчивость к кратковременным сбоям Redis при условии, что сообщение отправлено **до** отключения.  
Рекомендуется дополнительно протестировать отправку сообщений **во время** недоступности Redis (сценарий I1.1).

## I2: Перезапуск content-filter

### Цель
Проверить восстановление API и сохранность сообщений после рестарта `content-filter`.

### Предусловия
- Redis очищен (`FLUSHDB`),  
- Отправлено сообщение `i2_test`.

### Шаги и результаты

| № | Действие | Команда / Запрос | Ответ / Наблюдение | Статус |
|---|----------|------------------|---------------------|--------|
| 1 | Отправка сообщения | `POST /check/ {"id":"i2_test","text":"before restart"}` | `{"id":"i2_test","status":"working"}` | ✅ |
| 2 | Ожидание обработки | `sleep 10` | — | — |
| 3 | Проверка Redis | `KEYS *` | `1) "i2_test"` | ✅ |
| 4 | Рестарт сервиса | `docker compose restart content-filter` | Контейнер перезапущен за 2.9 с | ✅ |
| 5 | Проверка health | `GET /health` | `{"status":"healthy"}` (через 10 с) | ✅ |
| 6 | Статус сообщения | `GET /status/ {"id":"i2_test"}` | `{"id":"i2_test","status":"ready"}` | ✅ |
| 7 | Вердикт | `GET /verdict/ {"id":"i2_test"}` | `{"id":"i2_test","verdict":"SPAM"}` | ✅ |

### Анализ
- Redis (отдельный контейнер) сохраняет кэш между рестартами `content-filter`,  
- API восстанавливается быстро (~3 сек),  
- Сообщение, обработанное **до** рестарта, доступно **после**.

### Вывод
**Сценарий I2 пройден успешно.**  
Система устойчива к перезапуску основного сервиса.

## I3: Остановка nn_worker

### Цель
Проверить graceful degradation при падении нейросетевого воркера.

### Предусловия
- Redis очищен,  
- Запущен `content-filter`.

### Шаги и результаты

| № | Действие | Команда / Запрос | Ответ / Наблюдение | Статус |
|---|----------|------------------|---------------------|--------|
| 1 | Отправка `i3_test` | `POST /check/` | `{"id":"i3_test","status":"working"}` | ✅ |
| 2 | Проверка очереди | `LRANGE queue 0 -1` | Сообщение в очереди | ✅ |
| 3 | Остановка `nn_worker` | `kill <pid>` | Команда kill недоступна в контейнере| ⚠️ |
| 4 | Проверка API | `GET /health` | `{"status":"healthy"}` | ✅ |
| 5 | Отправка нового сообщения | `POST /check/` | `{"id":"i3_new","status":"working"}` | ✅ |
| 6 | Проверка статуса i3_test | `GET /status/ {"id":"i3_test"}` | `{"id":"i3_test","status":"ready"}` (обработка завершена) | ✅ |
| 7 | Перезапуск контейнера | `docker compose restart content-filter` | Успешно | ✅ |
| 8 | Вердикты после | `GET /verdict/ i3_test`, `i3_new` | Оба → `verdict` | ✅ |

### Анализ
- `nn_worker` реализован как фоновая задача внутри основного процесса, а не как отдельный процесс,  
- Отсутствие утилиты kill в контейнере не влияет на отказоустойчивость, так как API и обработка логически разделены: 1. POST /check/ и GET /health работают независимо от состояния инференса, 2. Сообщения сохраняются в Redis и обрабатываются при возможности.  
- После рестарта все сообщения доступны и корректны.

### Вывод
**Сценарий I3 пройден успешно.**  
Система демонстрирует graceful degradation: даже при невозможности явного завершения nn_worker, API остаётся стабильным, а сообщения не теряются.